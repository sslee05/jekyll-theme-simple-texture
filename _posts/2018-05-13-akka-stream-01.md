---
layout: post
title: "akka Stream 첫번째"
description: "akka stream"
categories: [scala-akka]
tags: [scala,스칼라,akka,아카,Stream,스트림]
redirect_from:
  - /2018/05/12/
---

> akka FSM.
>


* Kramdown table of contents
{:toc .toc}

# akka-stream
akka-stream은 처리연산의 설계도의 component pipe 조합이다.  
이들은 Stream 이라는 이름처럼 지연를 이용한 실행시 어떻게 처리할 것인지에 대한 설계도이다.  
설계도는 Stream component들의 조각들은 재사용 가능하고, 또 이를 다른 최종 설계도에 다른 부품으로 사용 할 수 가 있다. 그리고 이후에 이를 실행하면 설계도에 따른 처리연산을 진행하게 된다.  
akka-stream에서 기본적으로 기역해야할 항목들은 다음과 같다.  
1. Source
2. Sink
3. Flow
4. Shape
5. Graph
6. Materializer  

이들의 정의와 특징들과 사용법들을 알아 보자.  

akka는 설계도를 설계하고 이들(이들은 모두 Graph이다)은 ActorSystem위에서 실제 data를 streaming하는데 필요한 모든 작업을 수해하는 Actor로 변환된다  

# Source
{% highlight scala %}
final class Source[+Out, +Mat](생략...) extends FlowOpsMat[Out, Mat] 
	with Graph[SourceShape[Out], Mat]
{% endhighlight %}
위의 코드는 알아보기 쉽게 생략했는데 위에 코드를 보면 2개의 type parameter를 받고, Source는 Graph의 유형임을 알 수 있다.  
Source는 하나의 오픈 출력을 갖는 스트림 처리 단계들의 집합이다. 
그리고 2개의 type parameter중 1번째는 Source가 출력하는 유형이며, 2번째 parameter는 실체화시 유지되는 반환유형이다. 이는 추후 Materializer부분에서 이야기 하기로 한다.  
akka-io 에 나와 있는 예제이다.  
{% highlight scala %}
//actorsystem
implicit val system = ActorSystem("QuickStart")
//실체화시 암시적인자 필요 
implicit val materializer = ActorMaterializer()


//(1 to 100) 까지의 Int를 열린출력으로 내보냄을 나타내는 설계도 
//NotUsed는 실체화 값을 가지지 않는다. 
//이는 설계도 일뿐 실행시 실제로 처리가 진행 
val source: Source[Int, NotUsed] = Source(1 to 100)

//처리가 진행 
//처리 결과의 실체화는 Future[Done] 
val result: Future[Done] = source.runForeach(i => println(i))(materializer)

result.onComplete{
	case Success(a) => println(a) 
    case Failure(e) => println(e)}(system.dispatcher) 

//Source는 Graph이며 stream처리 설계도 이고 열린 output 출력을 가진다. 
val factorial:Source[BigInt, NotUsed] = 
	source.scan(BigInt(1))((ac, i) => ac * i)

//materializer를 가지고 실행시 return type는 처리한 byte수의 Future[IOResult] 이다.
val fileResult: Future[IOResult] = 
	factorial.map(num => ByteString(s"$num\n"))
		.runWith(FileIO.toPath(Paths.get("/Users/sslee/temp/factorial.txt")))

//종료후 actorSystem은 내려가지 않으므로 완료시 actorSystem를 종료
fileResult.onComplete{ iors => 
  println("@@@@"+iors)
  system.terminate()
}(system.dispatcher)

{% endhighlight %}

# Sink
한개의 열린 입력이 있다. 아래 정의를 보면 이 또한 Source 와 비슷하고 이역시 사실 Graph이다.
{% highlight scala %}
final class Sink[-In, +Mat](생략...) extends Graph[SinkShape[In], Mat]
{% endhighlight %}

아래 코드를 보자 
{% highlight scala %}
implicit val system = ActorSystem("streamSystem")
implicit val materializer = ActorMaterializer()
implicit val executionContext = system.dispatcher

//어디로 보낼지는 모르지만 file 읽어 file내용을 ByteString으로 
val source: Source[ByteString, Future[IOResult]] = 
	FileIO.fromPath(Paths.get("/Users/sslee/temp/factorial.txt"))

//어떤 거에 연결 될지 모르지만 ByteString을 받아 File 로  
val sink: Sink[ByteString, Future[IOResult]] = 
	FileIO.toPath(Paths.get("/Users/sslee/temp/factorial2.txt"))

//source + sink = 1개의 열린 출력 + 1개의 열린 입력 = Graph(여기서의 최종 설계도)
val graph: RunnableGraph[Future[IOResult]] = source to sink

//설계도를 실행 실행결과 로는 Future에 Source에서의 IOResult가 들어있고 이를 println으로 console출력 한다.graph.run은 Future[IOResult] 이다.
graph.run().foreach { result =>
  println(s"${result.status}, ${result.count} bytes read.")
  system.terminate()
}
{% endhighlight %}
위의 코드를 보면 source to sink로 한개의 열린 출력과 한개의 열린 출력을 연결하여 Graph를 만들엇다. 위에서 RunnableGraph 선언되면서 실행 되지 않는다. 이는 설계도 일뿐이다. 실제 run를 실행시 실행되며 이를 실체화 했다고 말 한다.  
실체화의 결과에는 Sink에서 쓴 byte수가 아닌,Source에서 읽은 byte수가 들어있다. Keep.left가 default이기 때문이다. 이는 이후에 Materializer에서 설명하기로 한다.  
run()시 Materializer가 암시적으로 사용되어 지는데 이는 실제로 Source의  publisher에 해당하는Actor와 Sink에 Subscriber에 해당하는 Actor를 만들어 Source에서 읽은 byteString를 한번에 하나씩 파일 싱크에 넘어 간다.

# Materializer
Graph를 실행시 암시적 Materializer를 필요로 했다. 그럼 이 Materializer 가 어떤 일을 내부적으로 하는지 알아 보자.  

Materializer는 RunnableGraph를 Graph를 실행하는 여러 Actor로 변환한다.
1.Source와 Sink의 연결를 점검
2.Source로 부터 ,위의 예제에서는 FileChannel을 열 FilePublisher Actor를 만들라고 한다.
3.Sink로 부터, 위의 예제에서는 FileChannel을 여는 FileSubScriber Actor를 만들라고 한다.
4.FileSubscriber를 FilePublisher에 가입 시킨다.
5.FilePublisher는 ByteString를 다 읽을때 까지 읽고, FileSubscriber는 이를 받아 File에 쓴다.
6.FilePublisher는 다 읽으면 작동을 중단하고 FileChannel를 닫고, FileSubscribe에게 달 읽었다고 OnComplete메시지가 도착하며, FileSubscriber는 자신이 쓴 file 를 닫는다.  

위에 stream 실행시에도 take, takeWhile 등으로 실행 중간에 조건에 따라 stream을 중지 할 수 있는데, 이는 폴키우사노가 쓴 funcional programming in scala 일명 빨간책을 보면 Stream을 연습하는 부분이 나오는데 lazy를 이용하여 take, takeWhile, forAll, exist를 해보았다면 이해하는데 도움이 될 것 이다.  

RunnableGraph를 또 실행하면 새로운 Actor 모음이 만들어지며 모든 처리가 처음부터 다시 시작한다.  

## Publisher와 Subscriber의 상호 작용
위의 예제에서 FilePublisher가 모든 데이터를 메모리에 올리면 OOM에 우려가 있다. 하지만 akka-stream은 그렇게 작동하지 않느다.  
FileSubscriber가 FilePublisher에게 한번에 처리할 유한개의 원소를 요청message를 비동기 요청한다. 이후 Publisher는 요청 갯수 이하 만큼 보낸다. 그리고 Publisher는 요청할 때만 다음 데이터를 읽는다.  
이는 구독자가 발생핮에게 자신이 처리할 수 있는 정보가 더 많거나 더 적다고 신호를 보내는데 이를 non-blocking pressure 라 한다.

## WatermarkRequestStrategy
akka-stream는 모든 원소를 하나하나 요청하고 발행하는 것이 아니라 묶음씩 요청하고 발생한다.  
구독자는 WatermarkRequestStrategy 전략를 사용하는데 이는 다음과 같다.  
버퍼의 크기에 현재 데이터 양이 최저이면 구독자는 최대수위까지 더 많은 데이터를 요청하여 버퍼에 full로 채운다. 반면 현재 데이터 양이 버퍼의 최대 바로 아래이면 데이터는 최고수위 - 현재 수위 만큼 요청한다.  
즉 버퍼의 수위에 따라 유동적으로 요청 크기가 달라 지며 중요한 것은 절대 최대 수위를 넘치지 않는 다는 것이다.  
원소자체의 크기 즉 file인 경우 file 에서 읽어오는 chunk크기의 default값은 8KB 이다.  
또 이 원소의 갯수를 지정할 수 있는데 이는  default값은 16으로 이를 계산하면 한번에 요청할 수 있는 최대 수위는 8 * 16 = 128KB가 된다.  
갯수 지정은 akka.streammaterializer.max-input-buffersize로 지정 할 수 있다.  
설정 file에 설정시 
{% highlight scala %}
akka.stream.materializer.max-input-buffer-size = 16
{% endhighlight %}
Materializer를 이용한 설정시
{% highlight scala %}
val materializer = ActorMaterializer(
  ActorMaterializerSettings(system)
    .withInputBuffer(
      initialSize = 64,
      maxSize = 64))
{% endhighlight %}

## materializer한 값 조합하기
Source[+Out, +Mat]와 Sink[-In, +Mat]에서 본 것 처럼 source와 sink는 실체화 되었을때 외부 값을 제공할 수 있다. Future[IOResult]는 실체화시 읽거나 쓴 바이트 수를 가지고 있다.  
to method는 default로 left 그러니깐 Source쪽 따라서 file에서 읽어서 처리한 byte수를 default로 한다. 이는 toMat method를 이용하여 right 혹은 left, right 둘다 도 할 수 있다.

{% highlight scala %}
//file에 쓴  byte 수 정보 
val graphKeepRight: RunnableGraph[Future[IOResult]] = 
	source.toMat(sink)(Keep.right)

graphKeepRight.run().foreach { result =>
	println(s"${result.status}, ${result.count} bytes read.")
	//system.terminate()
}

//file을 읽어들인 byte 수 와 file에 쓴 byte 수 
val graphKeepBoth: RunnableGraph[(Future[IOResult], Future[IOResult])] = 
	source.toMat(sink)(Keep.both)
val tt: (Future[IOResult], Future[IOResult]) = 
	graphKeepBoth.run()
Future.sequence(List(tt._1, tt._2)).foreach { rs => rs.foreach(println(_)) }

{% endhighlight %}
위에서는 component 조합이 2개이지만 여러게로 복잡해지면 Keep.right를 할 경우는 left부터 right까지 pipe 시 Mat유형의 전환을 유지를 신경써야 한다.  

[^1]: This is a footnote.

[kramdown]: https://kramdown.gettalong.org/
[Simple Texture]: https://github.com/yizeng/jekyll-theme-simple-texture
