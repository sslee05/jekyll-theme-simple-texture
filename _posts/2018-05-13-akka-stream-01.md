---
layout: post
title: "akka Stream 첫번째"
description: "akka stream"
categories: [scala-akka]
tags: [scala,스칼라,akka,아카,Stream,스트림]
redirect_from:
  - /2018/05/12/
---

> akka FSM.
>


* Kramdown table of contents
{:toc .toc}

# akka-stream
akka-stream은 처리연산의 설계도의 component pipe 조합이다.  
이들은 Stream 이라는 이름처럼 지연를 이용한 실행시 어떻게 처리할 것인지에 대한 설계도이다.  
설계도는 Stream component들의 조각들은 재사용 가능하고, 또 이를 다른 최종 설계도에 다른 부품으로 사용 할 수 가 있다. 그리고 이후에 이를 실행하면 설계도에 따른 처리연산을 진행하게 된다.  
akka-stream에서 기본적으로 기역해야할 항목들은 다음과 같다.  
1. Source
2. Sink
3. Flow
4. Shape
5. Graph
6. Materializer  

이들의 정의와 특징들과 사용법들을 알아 보자.  

akka는 설계도를 설계하고 이들(이들은 모두 Graph이다)은 ActorSystem위에서 실제 data를 streaming하는데 필요한 모든 작업을 수해하는 Actor로 변환된다  

# Source
{% highlight scala %}
final class Source[+Out, +Mat](생략...) extends FlowOpsMat[Out, Mat] 
	with Graph[SourceShape[Out], Mat]
{% endhighlight %}
위의 코드는 알아보기 쉽게 변경했는데 위에 코드를 보면 2개의 type parameter를 받고, Source는 Graph의 유형임을 알 수 있다.  
Source는 하나의 오픈 출력을 갖는 스트림 처리 단계들의 집합이다. 
그리고 2개의 type parameter중 1번째는 Source가 출력하는 유형이며, 2번째 parameter는 실체화시 유지되는 반환유형이다. 이는 추후 Materializer부분에서 이야기 하기로 한다.  
akka-io 에 나와 있는 예제이다.  
{% highlight scala %}
//actorsystem
implicit val system = ActorSystem("QuickStart")
//실체화시 암시적인자 필요 
implicit val materializer = ActorMaterializer()


//(1 to 100) 까지의 Int를 열린출력으로 내보냄을 나타내는 설계도 
//NotUsed는 실체화 값을 가지지 않는다. 
//이는 설계도 일뿐 실행시 실제로 처리가 진행 
val source: Source[Int, NotUsed] = Source(1 to 100)

//처리가 진행 
//처리 결과의 실체화는 Future[Done] 
val result: Future[Done] = source.runForeach(i => println(i))(materializer)

result.onComplete{
	case Success(a) => println(a) 
    case Failure(e) => println(e)}(system.dispatcher) 

//Source는 Graph이며 stream처리 설계도 이고 열린 output 출력을 가진다. 
val factorial:Source[BigInt, NotUsed] = 
	source.scan(BigInt(1))((ac, i) => ac * i)

//materializer를 가지고 실행시 return type는 처리한 byte수의 Future[IOResult] 이다.
val fileResult: Future[IOResult] = 
	factorial.map(num => ByteString(s"$num\n"))
		.runWith(FileIO.toPath(Paths.get("/Users/sslee/temp/factorial.txt")))

//종료후 actorSystem은 내려가지 않으므로 완료시 actorSystem를 종료
fileResult.onComplete{ iors => 
  println("@@@@"+iors)
  system.terminate()
}(system.dispatcher)

{% endhighlight %}

# Sink
한개의 열린 입력이 있다. 아래 정의를 보면 이 또한 Source 와 비슷하고 이역시 사실 Graph이다.
{% highlight scala %}
final class Sink[-In, +Mat](생략...) extends Graph[SinkShape[In], Mat]
{% endhighlight %}

아래 코드를 보자 
{% highlight scala %}
implicit val system = ActorSystem("streamSystem")
implicit val materializer = ActorMaterializer()
implicit val executionContext = system.dispatcher

//어디로 보낼지는 모르지만 file 읽어 file내용을 ByteString으로 
val source: Source[ByteString, Future[IOResult]] = 
	FileIO.fromPath(Paths.get("/Users/sslee/temp/factorial.txt"))

//어떤 거에 연결 될지 모르지만 ByteString을 받아 File 로  
val sink: Sink[ByteString, Future[IOResult]] = 
	FileIO.toPath(Paths.get("/Users/sslee/temp/factorial2.txt"))

//source + sink = 1개의 열린 출력 + 1개의 열린 입력 = Graph(여기서의 최종 설계도)
val graph: RunnableGraph[Future[IOResult]] = source to sink

//설계도를 실행 실행결과 로는 Future에 Source에서의 IOResult가 들어있고 이를 println으로 console출력 한다.graph.run은 Future[IOResult] 이다.
graph.run().foreach { result =>
  println(s"${result.status}, ${result.count} bytes read.")
  system.terminate()
}
{% endhighlight %}
위의 코드를 보면 source to sink로 한개의 열린 출력과 한개의 열린 출력을 연결하여 Graph를 만들엇다. 위에서 RunnableGraph 선언되면서 실행 되지 않는다. 이는 설계도 일뿐이다. 실제 run를 실행시 실행되며 이를 실체화 했다고 말 한다.  
실체화의 결과에는 Sink에서 쓴 byte수가 아닌,Source에서 읽은 byte수가 들어있다. Keep.left가 default이기 때문이다. 이는 이후에 Materializer에서 설명하기로 한다.  
run()시 Materializer가 암시적으로 사용되어 지는데 이는 실제로 Source의  publisher에 해당하는Actor와 Sink에 Subscriber에 해당하는 Actor를 만들어 Source에서 읽은 byteString fmf 한번에 하나씩 파일 싱크에 넘어 간다.

[^1]: This is a footnote.

[kramdown]: https://kramdown.gettalong.org/
[Simple Texture]: https://github.com/yizeng/jekyll-theme-simple-texture
