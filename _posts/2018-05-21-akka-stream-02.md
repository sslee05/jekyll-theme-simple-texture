---
layout: post
title: "akka Stream 두번째"
description: "akka stream"
categories: [scala-akka]
tags: [scala,스칼라,akka,아카,Stream,스트림]
redirect_from:
  - /2018/05/21/
---

> akka FSM.
>


* Kramdown table of contents
{:toc .toc}

# akka-http 에서의 akka-stream
akka-http에서 client로 부터의 data를 akka-stream을 이용하여 server쪽으로 읽어 들인다.  
핵심은 앞전에 post에서 이야기한 akka-stream을 그대로 이용하고 여기서 중요한 것은 route에서 directive 지시자 안에서 어떻게 Source를 얻고 Sink로 내보내는지를 보면 된다.  
akka.http.scaladsl.model.HttpEntity 로부터 dataBytes를 이용하여 Source[ByteString,_\]으로 Source를 얻어 기존에 akka-stream으로 했던 stream component를 이용하는 방법과, HttpEntity로 부터 custom Unmarshaller를 통해 Source[Event,_\]형태로 source를 바로 얻을 수 도 있다.  
akka-http에서의 akka-stream부분의 사용에 초점을 두는 것 이므로 akka-http는 추후 akka-http post에서 보자.  

# Http를 통한 Stream받기
## post로 응답 처리 
akka-http에 관한 부분은 생략하고 route부분의 Directive에서 어떻게 stream을 얻는지를 보자
{% highlight scala %}
def postRoute = pathPrefix("logs" / Segment) { logId =>
  pathEndOrSingleSlash { 
    post {
      entity(as[HttpEntity]) { entity =>
        onComplete(
          entity.dataBytes // Source[ByteString,_]
            .via(flow)
            .toMat(getSinkLogFile(logId))(Keep.right)
            .run()
        ) {
          case Success(IOResult(count, Success(Done))) =>
            complete((StatusCodes.OK, LogReceipt(logId, count)))
          case Success(IOResult(count, Failure(e))) =>
            complete((
              StatusCodes.BadRequest,
              ParseError(logId, e.getMessage)
            ))
          case Failure(e) =>
            complete((
              StatusCodes.BadRequest,
              ParseError(logId, e.getMessage)
            ))
        }
      }
    }
  }
}
{% endhighlight %}
위의 코드는 HttpEntity로 부턴 Source[ByteString,_\] 를 얻는 예이다.  
이 후 flow는 앞전에 보았던 BidiFlow의 조합으로 stream을 구성한다.  
{% highlight scala %}
val inFlow: Flow[ByteString, Event, NotUsed] = JsonFraming.objectScanner(maxLine)
  .map(b => b.decodeString("UTF-8"))
  .map(s => s.parseJson.convertTo[Event])

val inFlowLinear: Flow[ByteString, Event, NotUsed] =   
  Framing.delimiter(ByteString("\n"), maxLine)
    .map(b => b.decodeString("UTF-8"))
    .map(s => s.parseJson.convertTo[Event])

val outFlow: Flow[Event, ByteString, NotUsed] = 
  Flow[Event].map(e => ByteString(e.toJson.compactPrint))

val bidiFlow: BidiFlow[ByteString, Event, Event, ByteString, NotUsed] =   
  BidiFlow.fromFlows(inFlow, outFlow)

// 흐름 turning 형은 Event -> Event
val flow: Flow[ByteString, ByteString, NotUsed] = bidiFlow.join(Flow[Event])

def getSinkLogFile(id: String): Sink[ByteString, Future[IOResult]] = 
FileIO.toPath(logFile(id), Set(CREATE,WRITE,APPEND))
{% endhighlight %}
일단 client로 부터의 Source 추출만 얻는다면 이후 는 다른 것이 없다.  
위의 예제는 client로 부터 넘어온  ByteString 을 Event로 변환 후 다시 ByteString으로 file에 기록 하는 것이다.  

## 응답 내보내기
응답은 server의  file을 읽어 client에 json으로 응답하는 부분이다.  
여기서도 기존의 stream Source[ByteString,Futre[IOResult\]\]는 기존과 같다. 이를 HttpEntity에게 넘기면 된다.
{% highlight scala %}
def getRoute = pathPrefix("logs" / Segment) { logId =>
  pathEndOrSingleSlash {
    get {
      if(Files.exists(logFile(logId))) {
        val src: Source[ByteString, Future[IOResult]] = logFileSource(logId)
        complete(
          HttpEntity(ContentTypes.`application/json`,src)    
        )
      }
      else {
        complete(StatusCodes.NotFound)
      }
    }
  }
}
{% endhighlight %}

# cumstom marshaller를 이용하기 
## 서버에서 응답 처리
위의 서버에서 응답처리의 예제에서 entity(as[HttpEntity\]) { entity => 를 보면 entity를 이용하여 Source[ByteString\]를 얻은 후 이후 stream를 이용했다.  
하지만 as[Source[Event,_\]\]를 하여 바로 원하는 type으로 변환된 stream를 얻을 수 있다.  
as 는 암시자로 Unmarshaller[T\] 이 필요하다. 따러서 Unmarshaller를 만들어야 한다.  
{% highlight scala %}
def createEventUnMarshaller(maxLine: Int, maxJsonObject: Int)  = {
  new Unmarshaller[HttpEntity, Source[Event, _]]  {
    def apply(entity: HttpEntity)(implicit es: ExecutionContext, mat: Materializer): Future[Source[Event, _]] = {
      val future = entity.contentType match {
        case ContentTypes.`application/json` =>
		  Future.successful{
			JsonFraming.objectScanner(maxJsonObject)
  			  .map(b => b.decodeString("UTF-8"))
			  .map(s => s.parseJson.convertTo[Event])
		  }
		case other =>
            Future.failed(new UnsupportedContentTypeException(supported)) 

        future.map(flow => entity.dataBytes.via(flow))(es)
	}
  }.forContentTypes(ContentTypes.`application/json`) 
}
{% endhighlight %}
Unmarshaller는 trait로 apply 생성 method를 구현하면 된다. 위의 예는 HttpEntity로 부터  contentType에 따라 Future[Source[Event,_\]\]으로 반환 한다.  
forContentTypes로 contentType이 application/json인 것만 변환한다.  

route에서는 as[HttpEntity\]가 아닌 as[Source[Event,_\]\]로 할 수 가 있다.(물론 암시가 scope에 있어야 한다.)  
{% highlight scala %}
//위에서 만든 unmarshaller 암시를 선언 
implicit val eventUnmarshaller: Unmarshaller[HttpEntity, Source[Event,_]] = 
    LogEntityMarshaller.createEventUnMarshaller(maxLine, maxJsObject)
def postRoute = pathPrefix("logs" / Segment) { logId =>
  pathEndOrSingleSlash {
	post {
      //as는 Unmarshaller 암시자가 필요
      entity(as[Source[Event,_]]) { esrc =>
        onComplete(
          esrc.via(eventToStringFlow)
            .toMat(fileSink(logId))(Keep.right)
            .run()    
        ) {
          case Success(IOResult(count, Success(Done))) => 
            complete((StatusCodes.OK, LogReceipt(logId, count)))
          case Success(IOResult(count, Failure(e))) => 
            complete((
              StatusCodes.BadRequest,
              ParseError(logId, e.getMessage)
            ))
          case Failure(e) => 
            complete((
              StatusCodes.BadRequest,
              ParseError(logId, e.getMessage)
            ))
        }
      }
    }
  }
}
{% endhighlight %}

## 응답 내보내기
akka.http.scaladsl.marshalling.Marshal.toResponseFor를 이용여 Source를 넘기면 된다.  
이때 toResponseFor metho는 ToResponseMarshaller[A\] 암시자가 필요하다.  
toResponseFor method는 다음과 같다.  
{% highlight scala %}
def toResponseFor(request: HttpRequest)(implicit m: ToResponseMarshaller[A],
	ec: ExecutionContext): Future[HttpResponse]
{% endhighlight %}

이제 Marshaller를 만드는 부분이다.  
{% highlight scala %}
val jsContent = ContentTypes.`application/json`
def createEventMarshaller(maxJsonObject: Int): 
  ToEntityMarshaller[Source[ByteString,_]] = {

  val jsMarshaller: Marshaller[Source[ByteString,_], HttpEntity.Chunked] = 
    Marshaller.withFixedContentType(jsContent) {
      source: Source[ByteString, _] => HttpEntity(jsContent, source)
    }
}
{% endhighlight %}
위에 첫번째 예제에서의 응답보낼때 HttpEntity를 이용하여 Source를 넘긴 부분과 같다.  
HttpEntity(ContentTypes.`application/json`,src)  
이제 route부분을 보자  

{% highlight scala %}
//위에서 만든 marshaller 암시를 선언 
implicit val eventMarshaller: ToEntityMarshaller[Source[ByteString, _]] = 
    LogEntityMarshaller.createEventMarshaller(maxJsObject)
    
def getRoute = pathPrefix("logs" / Segment) { logId =>
  pathEndOrSingleSlash {
    get {
      extractRequest{ req => 
        if(Files.exists(logFile(logId))) {
          val src = logFileSource(logId)
          //Marshal.toResponseFor 는 ToResponseMarshaller 암시자 를 필요로 한다.
          complete(Marshal(src).toResponseFor(req))
        } else {
          complete(StatusCodes.NotFound)
        }
      }
    }
  }
}
{% endhighlight %}

## JsonEntityStreamingSupport 이용
위의 예는 custom Unmarshaller를 만드는 예를 보기 위한 것이다. 이를 통행 HttpEntity로 부터 Source[Event,_\]를 얻었지만, akka.http.scaladsl.common.EntityStreamingSupport 객체를 이용하여  암시로 JsonEntityStreamingSupport를 선언하면 as[Source[Event,_\]\]를 asSourceOf[Event\] { Source[event,NotUsed] => ... 로 바로 사용 할 수가 있다.  
{% highlight scala %}
import akka.http.scaladsl.common.EntityStreamingSupport._
import akka.http.javadsl.common.JsonEntityStreamingSupport

implicit val entityStreamingSupport:JsonEntityStreamingSupport =
 EntityStreamingSupport.json
  
def postRoute = pathPrefix("logs" / Segment) { logId =>
  pathEndOrSingleSlash {
    post {
      //asSourceOf[T]는 JsonEntityStreamingSupport 암시자가 필요
      entity(asSourceOf[Event]) { esrc =>
        onComplete(
          esrc.via(eventToStringFlow)
            .toMat(fileSink(logId))(Keep.right)
            .run()    
        ){
          case Success(IOResult(count, Success(Done))) => 
            complete((StatusCodes.OK, LogReceipt(logId, count)))
          case Success(IOResult(count, Failure(e))) => 
            complete((
              StatusCodes.BadRequest,
              ParseError(logId, e.getMessage)
            ))
          case Failure(e) => 
            complete((
              StatusCodes.BadRequest,
              ParseError(logId, e.getMessage)
            ))
        }
      }
    }
  }
}

{% endhighlight %}



[^1]: This is a footnote.

[kramdown]: https://kramdown.gettalong.org/
[Simple Texture]: https://github.com/yizeng/jekyll-theme-simple-texture
